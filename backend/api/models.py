from typing import Any
from django.db import models

class AnalysisTranscript(models.Model):
    """Store the transcribed images from the analysis"""
    image_obj = models.ImageField(null=True, upload_to="Analysis/%Y-%m-%d %H:%M", help_text="The image that was transcribed")
    text_obj = models.TextField(help_text="The text that was inputted")
    is_question = models.BooleanField(null=True, help_text="Whether the text is a question or solution")
    transcript = models.TextField(help_text="The transcribed text from the image")
    created_at = models.DateTimeField(auto_now_add=True, help_text="When the transcription was created")

    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = "Analysis Transcripts"

    def __str__(self) -> str:
        return f"Transcript {self.id} - Question: {self.is_question}"
    
class GymTranscript(models.Model):
    """Stores the transcribed images from the gym analysis"""
    image_obj = models.ImageField(null=True, upload_to="Gym/%Y-%m-%d %H:%M", help_text="The image that was transcribed")
    text_obj = models.TextField(help_text="The text that was inputted")
    transcript = models.TextField(help_text="The transcribed text from the image")
    created_at = models.DateTimeField(auto_now_add=True, help_text="When the transcription was created")

    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = "Analysis Transcripts"

    def __str__(self) -> str:
        return f"Transcript {self.id} - created at {self.created_at.strftime('%Y-%m-%d %H:%M')}"
    
class Analysis(models.Model):
    """Stores the analysis result and parameters"""
    problem = models.TextField(help_text="The problem context")
    attempt = models.TextField(help_text="The attempt context")
    title = models.CharField(max_length=250, blank=True, help_text="The title of the analysis")
    tags = models.JSONField(default=list, blank=True, help_text="The concept tags")
    praise = models.TextField(blank=True, help_text="The part the student got right")
    diagnosis = models.TextField(blank=True, help_text="What the student got wrong")
    explanation = models.TextField(blank=True, help_text="The Feynman explanation generated by the AI")
    created_at = models.DateTimeField(auto_now_add=True, help_text="When the analysis was created")

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Analysis'
        verbose_name_plural = 'Analyses'
        indexes = [
            models.Index(fields=['-created_at']),
            models.Index(fields=['title']),
            models.Index(fields=['title', '-created_at'])
        ]

    def __str__(self)-> str:
        return f"Analysis {self.title or 'Untitled'} - created at {self.created_at.strftime('%Y-%m-%d %H:$M')}"
    
    def to_dict(self):
        """Converts the analysis to dictionary format"""
        return {
            'id': self.id,
            'problem': self.problem,
            'attempt': self.attempt,
            'title': self.title,
            'tags': self.tags,
            'praise': self.praise,
            'diagnosis': self.diagnosis,
            'explanation': self.explanation,
            'created_at': self.created_at.isoformat()
        }

class Chat(models.Model):
    """Stores each chat message and links it to the correct analysis"""
    class Role(models.TextChoices):
        USER = 'user', 'User'
        MODEL = 'model', 'Model'

    analysis = models.ForeignKey(
        Analysis,
        on_delete=models.CASCADE,
        related_name="Chats",
        help_text="The analysis the chat belongs to"
    )
    role = models.CharField(
        choices=Role.choices,
        max_length=10,
        help_text="The role of the message sender"
    )
    content = models.TextField(help_text="The content of the chat message")
    created_at = models.DateTimeField(auto_now_add=True, help_text="When the chat message was created")

    class Meta:
        ordering = ['created_at']
        verbose_name = 'Chat Message'
        verbose_name_plural = 'Chat Messages'
        indexes = [
            models.Index(fields=['analysis', 'created_at']),
            models.Index(fields=['role']),
        ]

    def __str__(self) -> str:
        return f"Chat Message {self.id} - Role: {self.role} - created at {self.created_at.strftime('%Y-%m-%d %H:%M')}"

class GymSesh(models.Model):
    """Store the gym result and parameter"""
    class Status(models.TextChoices):
        PENDING = 'pending', 'Pending'
        ACTIVE = 'active', 'Active'
        COMPLETED = 'completed', 'Completed'
        ABANDONED = 'abandoned', 'Abandoned'

    analysis = models.ForeignKey(
        Analysis,
        on_delete=models.CASCADE,
        related_name="Gym_analyses",
        help_text="The analysis the gym session belongs to"
    )
    status = models.CharField(max_length=20, 
        choices=Status.choices, 
        default=Status.PENDING,
        db_index=True,
        help_text="The status of the gym session"
    )
    num_questions = models.IntegerField(default=1, help_text="The number of questions the user solved")
    score = models.IntegerField(default=0, blank=True, help_text="The number of questions answered correctly")
    created_at = models.DateTimeField(auto_now_add=True, help_text="When the gym session started")
    started_at = models.DateTimeField(null=True, blank=True, help_text="When the user started the gym session")
    completed_at = models.DateTimeField(null=True, blank=True, help_text="When the gym session ended")

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Gym Sesh'
        verbose_name_plural = 'Gym Sessions'
        indexes = [
            models.Index(fields=['-created_at']),
            models.Index(fields=['analysis', '-created_at']),
            models.Index(fields=['analysis', 'status'])
            ]

    def __str__(self) -> str:
        return f"Gym session {self.id} - created at {self.created_at.strftime('%Y-%m-%d %H:%M')}"
    
    @property
    def to_percentage(self):
        """Calculates the percentage of the correct answer"""
        if self.num_questions == 0:
            return 0
        return round((self.score/ self.num_questions) * 100, 1)
    
class GymQuestions(models.Model):
    """Stores each gym questions and links it to the correct Gym session"""
    class Status(models.TextChoices):
        PENDING = 'pending', 'Pending'
        TRANSCRIBING = 'transcribing', 'Transcribing'
        EVALUATING = 'evaluating', 'Evaluated'
        EVALUATED = 'evaluated', 'Evaluated'
        ERROR = 'error', 'Error'

    gym_sesh = models.ForeignKey(
        GymSesh,
        on_delete=models.CASCADE,
        related_name="Questions",
        help_text="The gym session the questions belong to"
    )
    status = models.CharField(
        choices=Status.choices,
        max_length=20,
        default=Status.PENDING,
        db_index=True,
        help_text="The status of the question"
    )
    question = models.TextField(help_text="The question text")
    question_number = models.IntegerField(help_text="The question number")
    attempt = models.TextField(blank=True, help_text="The user's answer")
    is_correct = models.BooleanField(default=False, help_text="Is the user's answer correct")
    feedback = models.TextField(blank=True, help_text="The models feedback on the user's attempt")
    solution = models.TextField(blank=True, help_text="The models solution to the problem")
    is_answered = models.BooleanField(default=False, help_text="Whether the question has been answered")
    answered_at = models.DateTimeField(blank=True, null=True, help_text="When the question was answered")

    class Meta:
        ordering = ["question_number"]
        verbose_name = 'Gym Question'
        verbose_name_plural = 'Gym Questions'
        indexes = [
            models.Index(fields=['is_correct']),
            models.Index(fields=['gym_sesh', 'is_correct']),
            models.Index(fields=['status', 'gym_sesh'])
        ]

    def __str__(self)-> str:
        return f"Question {self.question_number} for Gym session {self.gym_sesh}"
    
    def to_dict(self)-> dict:
        """Converts the Gym Question to a python dictionary"""
        return {
            'id': self.id,
            'status': self.status,
            'question': self.question,
            'question_number': self.question_number,
            'attempt': self.attempt,
            'is_correct': self.is_correct,
            'feedback': self.feedback,
            'solution': self.solution,
            'is_answered': self.is_answered,
            'answered_at': self.is_answered
        }